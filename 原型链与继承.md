# 原型链与继承

参考：http://javascript.ruanyifeng.com/oop/prototype.html



#### 原型

- 作用：用于共享属性和方法
- 每一个函数都有一个prototype属性，该属性指向一个对象（称作原型对象）
- 原型对象中定义的属性和方法，为所有由该构造函数创建的实例对象共享。

- 实例只与原型对象有关，跟构造函数无关





#### 继承

- 盗用构造函数

- 组合继承

  - 使用原型链继承原型上的属性和方法，通过盗用构造函数继承实例属性

  ```
  function SuperType(name){ 
   this.name = name; 
   this.colors = ["red", "blue", "green"]; 
  } 
  SuperType.prototype.sayName = function() { 
   console.log(this.name); 
  }; 
  
  function SubType(name, age){ 
   // 继承属性
   SuperType.call(this, name); 
   this.age = age; 
  } 
  // 继承方法
  SubType.prototype = new SuperType(); 
  SubType.prototype.sayAge = function() { 
   console.log(this.age); 
  }; 
  
  let instance1 = new SubType("Nicholas", 29); 
  instance1.colors.push("black"); 
  console.log(instance1.colors); // "red,blue,green,black" 
  instance1.sayName(); // "Nicholas"; 
  instance1.sayAge(); // 29 
  let instance2 = new SubType("Greg", 27); 
  console.log(instance2.colors); // "red,blue,green" 
  instance2.sayName(); // "Greg"; 
  instance2.sayAge(); // 27 
  ```

  

- 寄生继承

  - 主要关注对象

  ```
  function createAnother(original){ 
   let clone = object(original); // 通过调用函数创建一个新对象
   clone.sayHi = function() { // 以某种方式增强这个对象
   	console.log("hi"); 
   }; 
   return clone; // 返回这个对象
  } 
  
  let person = { 
   name: "Nicholas", 
   friends: ["Shelby", "Court", "Van"] 
  }; 
  let anotherPerson = createAnother(person); 
  anotherPerson.sayHi(); // "hi" 
  ```

- 寄生式组合继承